\section{\sysname Design}

\sysname employs a two-level hierarchical approach for scheduling function instances 
and requests. At the inter-server level, complementary swarming placement groups 
and places functions with opposing CPU/memory needs onto the same server, maximizing 
node utilization and reuse. At the intra-server level, monotonic scale-up scheduling 
reorders each function’s requests by increasing resource demand, allowing a single 
sandbox to scale up incrementally and avoid restarts.

\subsection{Complementary Swarming Instance Placement}
\label{sec:design:placement}

% 1. 算法目标与概述 (Algorithm Objective & Overview)
%   - 一句话重申目标：解决跨函数异构性，通过互补放置提升利用率和复用。
%   - 简述执行流程：函数分类 -> 节点选择/配对 -> 任务映射。

% 2. 问题建模 (Problem Formulation)
%   - 将“将函数映射到节点”形式化为一个优化问题（可提及是NP-hard）。
%   - 定义关键变量：函数资源向量、节点容量、互补性度量。
%   - 明确优化目标：最大化节点资源利用率 + 最小化每节点承载的**相异函数数**（以促进复用）。

% 3. 启发式算法流程 (Heuristic Algorithm)
%   - 基于伪代码或步骤列表详细说明。
%   - 关键步骤：函数按CPU/内存比分类；为函数寻找“最互补”的现有节点或新节点；如何计算“互补度”。
%   - 解释“控制优化步长”如何具体实现（例如，每次增量处理一批新函数或节点状态更新）。

% 4. 算法属性保证 (Algorithmic Guarantees)
%   - **收敛性**：解释为何在可控步长下，算法能在有限迭代内达到稳定状态。
%   - **低开销**：“部分更新”机制如何运作（例如，仅重新计算受影响节点的分配，或定期而非每请求触发）。

% 5. 任务分配方案 (Task Assignment)
%   - 如何处理高需求函数的跨节点负载分割（Task-level load splitting）。
%   - 算法输出的“函数-节点”映射如何转化为实时调度决策。

\subsection{Monotonic Scale-up Task Scheduling}
\label{sec:design:scheduling}

% 1. 调度器目标与总览 (Scheduler Objective & Overview)
%   - 重申目标：解决函数内需求波动，实现无重启细粒度资源调整。
%   - 总览架构图：展示双队列、多沙箱、与K8s运行时交互的组件图。

% 2. 调度器核心结构 (Core Scheduler Structure)
%   - **双任务队列**：明确两个队列的作用（例如，Q1: 等待分配沙箱的任务；Q2: 已分配待执行的任务）。
%   - **排序规则**：队列按预测资源需求单调递增排序。
%   - **多沙箱均分优先级结构**：如何将不同函数的请求分配到不同沙箱，以及如何在沙箱间平衡负载。

% 3. 优先级设计 (Priority Design)
%   - 定义优先级函数，综合考虑等待时间、冷启动开销、资源需求。
%   - 解释如何通过“在优先级约束下策略性重排序”来延长队列，从而提升利用率和减少冷启动。

% 4. 事件驱动调度逻辑 (Event-driven Scheduling Logic)
%   - 列出关键事件：新请求到达、沙箱资源调整完成、沙箱空闲、资源回收触发。
%   - 描述调度器对每个事件的反应逻辑（可配流程图或状态机）。