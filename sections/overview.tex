\section{\sysname Overview}
\label{sec:overview}

{
\begin{figure}[t]
  \centering
  \includegraphics[width=\linewidth]{figures/design/overview.pdf}
  \vspace{-15pt}
  \caption{\sysname overview. \junyi{change strategy to plan? or even mapping}}
  \vspace{-15pt}
  \label{fig:overview}
\end{figure}
}

Figure~\ref{fig:overview} illustrates the overall architecture of \sysname, which operates at two levels: inter-node request dispatching and intra-node request scheduling. At the cluster level, incoming user requests are first directed to a request dispatcher, which monitors traffic patterns. These traffic statistics, along with function metadata and performance metrics, are forwarded to the dispatching plan generator which periodically generates dispatching plans. A dispatching plan is then used by the Request Dispatcher to decide request-to-node assignments.
Once assigned to a worker node, requests are entered into queues managed by the worker scheduler. This component maintains separate queues and priorities for different functions, while orchestrating instances within the node to handle request execution and in-place resource scaling. To enable this, \sysname introduces two key techniques: complementary swarming dispatching and monotonic scale-up scheduling.

\parabf{Complementary Swarming Request Dispatching.}
\sysname controls instance placement by establishing a mapping dictating how requests are distributed across the cluster. Using a heuristic algorithm, \sysname ensures that the collective resource demand of the function mix on each worker node aligns with the node's capacity, thereby maximizing utilization. Simultaneously, the system minimizes the number of distinct functions per node to increase instance reuse. For high-demand functions requiring deployment across multiple nodes, \sysname employs request-level load splitting to distribute the workload. By controlling the optimization step size, \sysname guarantees algorithm convergence and keeps computation time under 100 milliseconds. \junyi{you should also explain how it addresses challenge 1}

\parabf{Monotonic Scale-up Request Scheduling.}
\sysname designs its worker-level scheduling algorithm around the restart-free in-place pod scaling feature of Kubernetes. The scheduler maintains dual request queues, both sorted in ascending order of resource demand. This ordering ensures that, within a time window, the resource requirements of requests processed by an instance increase monotonically. Consequently, an instance can be scaled up incrementally to meet the growing demands of successive requests without over-provisioning, thereby increasing resource utilization without incurring restarts. To prevent starvation, \sysname determines queue priorities by holistically considering request queuing time, cold-start overhead, and resource requirements. By strategically reordering requests under priority constraints, \sysname effectively boosts resource utilization and reduces the frequency of cold starts.