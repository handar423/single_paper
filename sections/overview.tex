\section{\sysname Overview}
\label{sec:overview}

{
\begin{figure}[t]
  \centering
  \includegraphics[width=\linewidth]{figures/design/overview.pdf}
  \vspace{-15pt}
  \caption{\sysname overview.}
  \vspace{-15pt}
  \label{fig:overview}
\end{figure}
}

Figure~\ref{fig:overview} illustrates the overall architecture of \sysname. The scheduling framework operates at two levels: inter-node request dispatching and intra-node request scheduling. At the cluster level, incoming user requests are first directed to a request dispatcher, which monitors traffic patterns. These traffic statistics, along with function metadata and performance metrics, are forwarded to the dispatching strategy generator. This component periodically executes an algorithm to generate a dispatching strategy, which is then provided to the Request Dispatcher to guide request-to-node assignments.
Once assigned to a worker node, requests are entered into queues managed by the worker scheduler. This component maintains separate queues and priorities for different functions, while orchestrating instances within the node to handle request execution and in-place resource scaling. To enable this, \sysname introduces two key techniques: complementary swarming dispatching and monotonic scale-up scheduling.

\yunshan{\parabf{Complementary Swarming Dispatching.}
\sysname controls instance placement by establishing a mapping dictating how requests are distributed across the cluster.} Using a heuristic algorithm, \sysname ensures that the collective resource demand of the function mix on each worker node aligns with the node's capacity, thereby maximizing utilization. Simultaneously, the system minimizes the number of distinct functions per node to increase instance reuse. For high-demand functions requiring deployment across multiple nodes, \sysname employs request-level load splitting to distribute the workload. By controlling the optimization step size, \sysname guarantees algorithm convergence and keeps computation time under 100 milliseconds.

\parabf{Monotonic Scale-up Scheduling.}
\sysname designs its worker-level scheduling algorithm around the restart-free in-place pod scaling feature of Kubernetes. The scheduler maintains dual task queues, both sorted in ascending order of resource demand. This ordering ensures that, within a time window, the resource requirements of tasks processed by an instance increase monotonically. Consequently, an instance can be scaled up incrementally to meet the growing demands of successive tasks without over-provisioning, thereby increasing resource utilization without incurring restarts. To prevent starvation, \sysname determines queue priorities by holistically considering task waiting time, cold-start overhead, and resource requirements. By strategically reordering tasks to extend queue lengths under priority constraints, \sysname effectively boosts resource utilization and reduces the frequency of cold starts.