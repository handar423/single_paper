\section{Implementation}
\label{sec:implementation}

We implement a prototype of \sysname with $\sim$3100 LOC in Python, with 
Kubernetes~\cite{k8s} for instance management, Minio~\cite{MinIO} for function 
data management, and SciPy~\cite{scipy} for workload prediction.

\parabf{Instance manager.} We use containers as the serverless function instance 
based on the Kubernetes container orchestration. Each function instance is exposed 
via a unique pod IP address, which the scheduler maintains in a pod-IP mapping 
table. Container resource limits and instance placement are enforced through 
Kubernetes Pod specifications and node-affinity rules, respectively. In the 
prototype, the scheduler must manage a large number of instances and frequently 
interact with each one to perform lifecycle operationsâ€”including startup, access, 
scaling, termination, and health monitoring. To reduce control-plane overhead, 
our implementation leverages the Python Kubernetes client library in a multi-process 
and multi-coroutine architecture. Since some benchmarks require reading from and 
writing to external data during execution, we additionally deploy a MinIO service 
within the cluster to provide a unified data management layer for the function 
system.

\parabf{Scheduler.} The scheduler in the prototype consists of four modules. 
i) The cluster-level instance placement manager runs periodically (currently 
every minute), executes the complementary swarming placement algorithm, 
and passes the resulting to the task dispatcher process. ii) The cluster 
task dispatcher, operating in a separate process, assigns each incoming task to 
a worker node according to the placement plan. iii) The worker-level task 
scheduler maintains local task queues on each worker and decides when and which 
task to execute based on the monotonic scale-up task scheduling policy. 
iv) The system monitor collects real-time resource usage, records per-function 
metrics (cold-start time, execution duration, resource demand distribution), and 
generates load forecasts. For prediction, we currently employ a basic FFT-based 
method implemented with the Python SciPy library.
