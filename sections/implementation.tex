\section{Implementation}
\label{sec:implementation}

We implement a prototype of \sysname with $\sim$3100 LOC in Python, with 
Kubernetes~\cite{k8s} for instance management, Minio~\cite{MinIO} for function 
data management, and SciPy~\cite{scipy} for workload prediction.

\parabf{Instance manager.} We use containers as the serverless function instance 
based on the Kubernetes container orchestration. Each function instance is exposed 
via a unique Pod IP address, which the scheduler maintains in a pod-IP mapping 
table. Container resource limits and instance placement are enforced through 
Kubernetes Pod specifications and node-affinity rules, respectively. In the 
prototype, the scheduler must manage a large number of instances and frequently 
interact with each one to perform lifecycle operationsâ€”including startup, access, 
scaling, termination, and health monitoring. To reduce control-plane overhead, 
our implementation leverages the Python Kubernetes client library in a multi-process 
and multi-coroutine architecture. Since some benchmarks require reading from and 
writing to external data during execution, we additionally deploy a MinIO service 
within the cluster to provide a unified data management layer for the function 
system.

\parabf{Scheduler.} The scheduler in the prototype consists of four modules.
i) The dispatching plan generator runs as a periodic cluster-level service (currently every minute). It executes the complementary swarming dispatching algorithm to compute the optimized request dispatching plan, which is provided to the request dispatcher.
ii) The request dispatcher operates as a separate cluster-level process. It assigns each incoming request to a worker node according to the current dispatching plan received from the generator.
iii) The worker scheduler runs locally on each worker node. It maintains per-function request queues, enforces the monotonic scale-up scheduling policy to determine execution order, and triggers in-place pod scaling when required.
iv) The system monitor collects real-time resource usage and per-function metrics (e.g., cold-start time, execution duration, resource demand distribution). For load prediction, it currently employs a basic FFT-based method implemented with the Python SciPy~library~\cite{scipy}.
